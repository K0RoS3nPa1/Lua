-- Lade Rayfield von der richtigen Quelle
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

if not Rayfield then
    error("Rayfield konnte nicht geladen werden. Überprüfe die URL.")
end

local settings = {
    refill_at = 50,
    refill_end = 97,
    movespeed_at = 5,
    deliver_at = 5,
    stay_in_kitchen = true
}

local doCashier, doBoxer, doCook, doSupplier, doDelivery = false, false, false, false, false
local player = game:GetService("Players").LocalPlayer
local ffc = game.FindFirstChild
local RNG = Random.new()
local network
local character,root,humanoid

-- GUI Info-Anzeige
Rayfield:Notify({
    Title = "Info",
    Content = "GUI wird geladen...",
    Duration = 3
})

-- Erstelle das Hauptfenster für Rayfield
local window = Rayfield:CreateWindow({
    Name = "Pizza Factory Mod",
    LoadingTitle = "Lädt...",
    LoadingSubtitle = "Bitte warten",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "PizzaFactorySettings",
        FileName = "PizzaFactory"
    },
    Discord = {
        Enabled = false,
        Invite = ""
    },
    KeySystem = false
})

-- Erstelle ein Tab für die Einstellungen
local sectionSettings = window:CreateTab("Settings", 4483362458)

-- Refill Einstellungen
sectionSettings:CreateSlider({
    Name = "Refill At",
    Range = {1, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = settings.refill_at,
    Flag = "refill_at",
    Callback = function(value)
        settings.refill_at = value
    end
})

sectionSettings:CreateSlider({
    Name = "Refill End",
    Range = {1, 100},
    Increment = 1,
    Suffix = "%",
    CurrentValue = settings.refill_end,
    Flag = "refill_end",
    Callback = function(value)
        settings.refill_end = value
    end
})

-- Movespeed Einstellungen
sectionSettings:CreateSlider({
    Name = "Movespeed",
    Range = {1, 50},
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = settings.movespeed_at,
    Flag = "movespeed_at",
    Callback = function(value)
        settings.movespeed_at = value
    end
})

-- Toggle Buttons für verschiedene Funktionen
sectionSettings:CreateToggle({
    Name = "Cashier Aktivieren",
    CurrentValue = doCashier,
    Flag = "doCashier",
    Callback = function(bool)
        doCashier = bool
    end
})

sectionSettings:CreateToggle({
    Name = "Cook Aktivieren",
    CurrentValue = doCook,
    Flag = "doCook",
    Callback = function(bool)
        doCook = bool
    end
})

sectionSettings:CreateToggle({
    Name = "Boxer Aktivieren",
    CurrentValue = doBoxer,
    Flag = "doBoxer",
    Callback = function(bool)
        doBoxer = bool
    end
})

sectionSettings:CreateToggle({
    Name = "Delivery Aktivieren",
    CurrentValue = doDelivery,
    Flag = "doDelivery",
    Callback = function(bool)
        doDelivery = bool
    end
})

sectionSettings:CreateToggle({
    Name = "Supplier Aktivieren",
    CurrentValue = doSupplier,
    Flag = "doSupplier",
    Callback = function(bool)
        doSupplier = bool
    end
})

-- Warte-Schleife, damit das GUI nicht sofort geschlossen wird


-- Info-Anzeige beim Schließen
Rayfield:Notify({
    Title = "Beendet",
    Content = "Das GUI wurde geschlossen.",
    Duration = 3
})





for name in pairs(supplyCounts) do
    local counterName = name == "Dew" and "CounterMountainDew" or "Counter" .. name
    local counterModel = workspace:FindFirstChild("SupplyCounters") 
        and workspace.SupplyCounters:FindFirstChild("Model")
        and workspace.SupplyCounters.Model:FindFirstChild(counterName)

    if counterModel and counterModel:FindFirstChild("a") and counterModel.a:FindFirstChild("SG") and counterModel.a.SG:FindFirstChild("Counter") then
        local lbl = counterModel.a.SG.Counter

        -- Setze Standardwert falls nil
        supplyCounts[name] = tonumber(lbl.Text) or 0  

        -- Beobachte Änderungen im Text
        lbl:GetPropertyChangedSignal("Text"):Connect(function()
            supplyCounts[name] = tonumber(lbl.Text) or 0
            print("Updated", name, "to", supplyCounts[name]) -- Debugging
        end)
    else
        warn("Fehlendes SupplyCounter für: " .. name)
    end
end


-- Deine anderen Funktionen wie `FindFirstCustomer`, `FindBoxes` und weitere bleiben unverändert
--Kassierer
local function FindFirstCustomer()
    local children = workspace.Customers:GetChildren()  -- Holen Sie alle Kinderobjekte des 'Customers' Ordners im Workspace
    for i = 1, #children do  -- Iteration durch alle Kinderobjekte
        local c = children[i]  -- Das aktuelle Kindobjekt (Kunde)

        -- Überprüfen, ob der Kunde die erforderlichen Eigenschaften hat:
        if ffc(c, "Head") and ffc(c, "Humanoid") and c.Head.CFrame.Z < 102 and ffc(c.Head, "Dialog") and ffc(c.Head.Dialog, "Correct") and
           ((c.Humanoid.SeatPart and c.Humanoid.SeatPart.Anchored) or (c.Humanoid.SeatPart == nil and (c.Head.Velocity.Z ^ 2) ^ 0.5 < 0.0001)) then

            -- Wenn alle Bedingungen erfüllt sind, überprüfen Sie den Dialog des Kunden und legen Sie die Bestellung fest
            local dialog = c.Head.Dialog.Correct.ResponseDialog or ''
            local order = "MountainDew"  -- Standardbestellung ist Mountain Dew (falls der Dialog nichts anderes ergibt)

            -- Wenn der Dialog mit "instead." endet, wird dieser Teil abgeschnitten
            if dialog:sub(-30) == "instead." then
                dialog = dialog:sub(-30)
            end

            -- Bestimmen der Bestellung basierend auf dem Dialogtext
            if dialog:find("pepperoni", 1, true) then
                order = "PepperoniPizza"  -- Bestellung wird auf "PepperoniPizza" gesetzt
            elseif dialog:find("sausage", 1, true) then
                order = "SausagePizza"  -- Bestellung wird auf "SausagePizza" gesetzt
            elseif dialog:find("cheese", 1, true) then
                order = "CheesePizza"  -- Bestellung wird auf "CheesePizza" gesetzt
            end

            -- Rückgabe des Kunden und der Bestellung
            return c, order
        end
    end
end
--

-- Boxer
local boxPtick = 0  -- Variablen zum Überprüfen der Boxen
local boxDtick = 0  -- Weitere Variable zum Überprüfen der Boxen

-- Funktion zum Finden von Boxen, die Pizza enthalten oder leer sind
local function FindBoxes()
    local c, o, f  -- Boxen-Variablen (geschlossen, offen ohne Pizza, offen mit Pizza)
    
    -- Alle Kinder (Boxen) im AllBox-Ordner durchsuchen
    local children = workspace.AllBox:GetChildren()
    for i = 1, #children do
        local b = children[i]  -- Jedes Kind der Boxen
        -- Überprüfen, ob die Box entweder Pizza enthält oder eine leere Box ist
        if ffc(b, "HasPizzaInside") or ffc(b, "Pizza") then
            -- Schließen: Box ohne Pizza und nicht fest verankert
            if c == nil and b.Name == "BoxClosed" and b.Anchored == false and not b.HasPizzaInside.Value then
                c = b
            -- Offen und leer: Box, die geöffnet ist und keine Pizza enthält
            elseif o == nil and b.Name == "BoxOpen" and b.Anchored == false and not b.Pizza.Value then
                o = b
            -- Offen und mit Pizza: Box, die geöffnet ist und Pizza enthält
            elseif f == nil and (b.Name == "BoxOpen" and b.Pizza.Value) or (b.Name == "BoxClosed" and b.HasPizzaInside.Value) then
                f = b
            end
            -- Rückgabe, wenn alle drei Boxen gefunden wurden
            if c and o and f then
                return c, o, f
            end
        end
    end
    -- Falls nicht alle Boxen gefunden wurden, wird nil zurückgegeben
    return c, o, f
end

-- Funktion zum Finden der Pizza und Mountain Dew, die für das Verpacken erforderlich sind
local function FindBoxingFoods()
    local p, d  -- Variablen für Pizza und Dew
    
    -- Alle Kinder (Lebensmittel) im BoxingRoom durchsuchen
    local children = workspace.BoxingRoom:GetChildren()
    for i = 1, #children do
        local f = children[i]  -- Jedes Kind im BoxingRoom
        -- Überprüfen, ob das Objekt nicht verankert ist
        if not f.Anchored then
            -- Pizza finden
            if p == nil and f.Name == "Pizza" then
                p = f
            -- Mountain Dew finden
            elseif d == nil and f.Name == "Dew" then
                d = f
            end
            -- Rückgabe, wenn sowohl Pizza als auch Dew gefunden wurden
            if p and d then
                return p, d
            end
        end
    end
    -- Falls entweder Pizza oder Dew nicht gefunden wurden, wird nil zurückgegeben
    return p, d
end
-- boxer end
local orderDict = {["3540529228"] = "Cheese", ["3540530535"] = "Sausage", ["3540529917"] = "Pepperoni", ["2512571151"] = "Dew", ["2512441325"] = "Dew", ["11874352009"] = "Dew"}
local cookingDict = {Cheese = 0, Sausage = 0, Pepperoni = 0, Dew = 0}
local cookPtick = 0
local cookDtick = 0
local cookWarned = false
local boxerWarned = false

-- Koch
local function getOrders()
    local orders = {}
    local tempCookingDict = {}
    
    -- Kopiert die aktuellen Bestellungen aus dem cookingDict
    for i, v in pairs(cookingDict) do
        tempCookingDict[i] = v
    end
    
    local children = workspace.Orders:GetChildren() -- Alle Bestellungen aus dem "Orders"-Ordner im Workspace holen
    
    -- Durchläuft alle Bestellungen
    for i = 1, #children do
        local o = orderDict[children[i].SG.ImageLabel.Image:match("%d+$")] -- Bestell-ID herausfinden und den Artikel zuordnen
        
        if o then
            -- Wenn es noch Pizzen zu kochen gibt, wird die Zählung in tempCookingDict reduziert
            if tempCookingDict[o] > 0 then
                tempCookingDict[o] = tempCookingDict[o] - 1
            -- Überprüft, ob genügend Zutaten vorhanden sind
            elseif (o == "Dew" and #workspace.AllMountainDew:GetChildren() > 0) or (supplyCounts[o] > 0 and supplyCounts.TomatoSauce > 0 and supplyCounts.Cheese > 0) then
                orders[#orders + 1] = o -- Fügt die Bestellung der Liste hinzu
            end
        end
    end
    return orders -- Gibt die Bestellliste zurück
end

-- Funktion, um die erste nicht verbrannte Mountain Dew Flasche zu finden
local function FindFirstDew()
    local children = workspace.AllMountainDew:GetChildren() -- Alle Dew-Flaschen durchsuchen
    for i = 1, #children do
        local d = children[i]
        if (ffc(d, "IsBurned") == nil or d.IsBurned.Value == false) and not d.Anchored then
            return d -- Gibt die erste nicht verbrannte Dew-Flasche zurück
        end
    end
end

-- Funktion, um eine "schlechte" Mountain Dew Flasche zu finden (innerhalb eines bestimmten Bereichs)
local function FindBadDew()
    local children = workspace.AllMountainDew:GetChildren() -- Alle Dew-Flaschen durchsuchen
    for i = 1, #children do
        local d = children[i]
        if (ffc(d, "IsBurned") == nil or d.IsBurned.Value == false) and d.Position.X > 53 and d.Position.Z > 50 and not d.Anchored then
            return d -- Gibt die Dew-Flasche zurück, die die Bedingungen erfüllt
        end
    end
end

-- Funktion, um guten Teig und den passenden Teig für die Bestellung zu finden
local function FindDoughAndWithout(str)
    local goodraw, p, raw, trash
    local children = workspace.AllDough:GetChildren()
    
    -- Mische die Teigstücke
    for i = #children, 2, -1 do
        local j = RNG:NextInteger(1, i)
        children[j], children[i] = children[i], children[j]
    end
    
    -- Durchlaufe alle Teigstücke
    for i = 1, #children do
        local d = children[i]
        if d.Anchored == false and #d:GetChildren() > 9 then
            -- Ignoriere schlechten Teig, der verbrannt oder mit Bugs ist
            if d.IsBurned.Value or d.HasBugs.Value or d.Cold.Value or (d.BrickColor.Name == "Bright orange" and ffc(d, "XBillboard")) then
                if trash == nil and d.Position.Y > 0 and ((d.Position * Vector3.new(1, 0, 1)) - Vector3.new(47.90, 0, 72.49)).Magnitude > 1 then
                    trash = d -- Weist schlechten Teig als "Müll" zu
                end
            elseif p == nil and d.BrickColor.Name == "Bright orange" then
                p = d -- Weist den normalen Teig zu
            elseif goodraw == nil and d.Position.X < 55 and d.BrickColor.Name == "Brick yellow" and ((str and not ffc(d.SG.Frame, str)) or (str == nil and ffc(d.SG.Frame, "Sausage") == nil and ffc(d.SG.Frame, "Pepperoni") == nil)) then
                if d.Mesh.Scale.Y < 1.1 then
                    goodraw = d -- Weist guten Teig zu
                else
                    raw = d -- Weist rohen Teig zu
                end
            end
            if goodraw and p and trash then
                return goodraw, p, trash -- Gibt guten Teig, normalen Teig und "Müll"-Teig zurück
            end
        end
    end
    return goodraw or raw, p, trash -- Gibt entweder guten Teig oder rohen Teig zurück
end

-- Funktion, um den Ofen in der Nähe einer Position zu finden
local function getOvenNear(pos)
    local children = workspace.Ovens:GetChildren() -- Alle Öfen durchsuchen
    for i = 1, #children do
        if ffc(children[i], "Bottom") and (children[i].Bottom.Position - pos).Magnitude < 1.5 then
            return children[i] -- Gibt den Ofen zurück, der in der Nähe der angegebenen Position ist
        end
    end
end

-- Funktion, um Teig in der Nähe einer Position zu finden
local function getDoughNear(pos)
    local children = workspace.AllDough:GetChildren() -- Alle Teigstücke durchsuchen
    for i = 1, #children do
        if (children[i].Position - pos).Magnitude < 1.5 then
            return children[i] -- Gibt das Teigstück zurück, das sich in der Nähe der angegebenen Position befindet
        end
    end
end

-- Funktion, um zu prüfen, ob der Ofen vollständig geöffnet ist
local function isFullyOpen(oven)
    return oven.IsOpen.Value == true and (oven.Door.Meter.RotVelocity.Z^2)^.5 < .0001 -- Gibt true zurück, wenn der Ofen vollständig geöffnet ist
end
--
local bcolorToSupply = {
    ["Dark orange"] = "Sausage", 
    ["Bright blue"] = "Pepperoni", 
    ["Bright yellow"] = "Cheese", 
    ["Bright red"] = "TomatoSauce", 
    ["Dark green"] = "Dew", 
    ["Brick yellow"] = "Dough", 
    ["Light stone grey"] = "Box", 
    ["Really black"] = "Dew", 
    ["Navy blue"] = "Dew"
}

local supplyButtons = {}
-- Durchsucht alle SupplyButtons und speichert sie in einer sortierten Tabelle
for i, v in ipairs(workspace.SupplyButtons:GetChildren()) do
    supplyButtons[i] = v.Unpressed
end
table.sort(supplyButtons, function(a, b) return a.Position.X < b.Position.X end)

local delTick = 0

-- Funktion zum Finden aller Lieferwerkzeuge, die im Spiel vorhanden sind
local function FindAllDeliveryTools(parent)
    local t = {}
    local children = parent:GetChildren()
    for i = 1, #children do
        local v = children[i]
        -- Überprüft, ob das Objekt ein Werkzeug ist und bestimmte Kriterien erfüllt
        if v.ClassName == "Tool" and v.Name:match("^%u%d$") and ffc(v, "Handle") and ffc(v, "House") and 
            (parent ~= workspace or (v.Handle.Position - Vector3.new(54.45, 4.02, -16.56)).Magnitude < 30) then
            t[#t + 1] = v
        end
    end
    return t
end

-- Funktion zum Finden des Hausobjekts basierend auf einer Adresse
local function getHousePart(address)
    local houses = workspace.Houses:GetChildren()
    for i = 1, #houses do
        local h = houses[i]
        -- Überprüft, ob das Haus die angegebene Adresse hat und die "GivePizza"-Eigenschaft enthält
        if ffc(h, "Address") and h.Address.Value == address and ffc(h, "GivePizza", true) then
            return ffc(h, "GivePizza", true)
        end
    end
end

-- Funktion, die ausgeführt wird, wenn ein Charakter dem Spiel hinzugefügt wird
local function onCharacterAdded(char)
    if not char then return end
    character = char
    root = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    humanoid:SetStateEnabled("FallingDown", false)  -- Deaktiviert den Zustand "FallingDown" für den Charakter
end

-- Charakter hinzufügen
onCharacterAdded(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterAdded)

-- Glattes Teleportieren (Version 2)
local function smoothTP2(cf)
    local cf0 = (cf - cf.p) + root.Position + Vector3.new(0, 0, 0)
    local diff = cf.p - root.Position
    local oldg = workspace.Gravity
    workspace.Gravity = 0
    for i = 0, diff.Magnitude, settings.movespeed_at do
        humanoid.Sit = false
        root.CFrame = cf0 + diff.Unit * i
        root.Velocity, root.RotVelocity = Vector3.new(), Vector3.new()
        wait()
    end
    root.CFrame = cf
    workspace.Gravity = oldg
end

-- Glattes Teleportieren
local function smoothTP(cf)
    if (cf.p - root.Position).Magnitude > 97 then
        local btns = workspace.JobButtons:GetChildren()
        if player:FindFirstChild("House") and player.House.Value then
            btns[#btns + 1] = player.House.Value:FindFirstChild("Marker")
        end
        table.sort(btns, function(a, b)
            return (a.Position - cf.p).Magnitude < (b.Position - cf.p).Magnitude
        end)
        if (btns[1].Position - cf.p).Magnitude < (cf.p - root.Position).Magnitude then
            game:GetService("ReplicatedStorage").PlayerChannel:FireServer("TeleportToJob", ((btns[1].Name == "Marker") and "House" or btns[1].Name))
            wait(0.9)
            if (cf.p - root.Position).Magnitude < 9 then
                return
            end
        end
    end
    smoothTP2(cf)
end

-- Verhindern, dass die Öfen in der falschen Weise verwendet werden
for _, o in ipairs(workspace.Ovens:GetChildren()) do
    if o:FindFirstChild("Bottom") then
        o.Bottom.CanTouch = false
    end
end
local function tryCook()
	for zz=1,38 do
		local order = getOrders()[1]
		local topping
		if order=="Pepperoni" or order=="Sausage" then topping=order end
		local cookD = FindFirstDew()
		local badD = FindBadDew()
		local raw,cookP,trash
		if topping then
			--pepperoni order avoids sausage dough and vice verca
			raw,cookP,trash = FindDoughAndWithout(topping=="Pepperoni" and "Sausage" or "Pepperoni")
		else
			raw,cookP,trash = FindDoughAndWithout()
		end
		local ovens = workspace.Ovens:GetChildren()
		for i=#ovens,1,-1 do
		    if #ovens[i]:GetChildren() < 10 then
		        table.remove(ovens,i)
		    end
		end
		for i = #ovens, 2, -1 do --shuffle
			local j = RNG:NextInteger(1, i)
			ovens[j], ovens[i] = ovens[i], ovens[j]
		end
		if doCook then
			local didsomething=false
			--move final pizza
			if cookP and tick()-cookPtick>0.8 then
				local oven = getOvenNear(cookP.Position)
				if oven==nil or oven.IsOpen.Value then
					cookPtick=tick()
					didsomething=true
					if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
					network:FireServer("UpdateProperty", cookP, "CFrame", CFrame.new(RNG:NextNumber(56,57),4.1,38))
				end
			end
			if order then
				if order=="Dew" and cookD and tick()-cookDtick>0.8 then
					--move dew if ordered
					cookDtick=tick()
					didsomething=true
					if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
					network:FireServer("UpdateProperty", cookD, "CFrame", CFrame.new(53,4.68,36.5))
				elseif order~="Dew" and raw and raw.Parent and supplyCounts[order]>0 and supplyCounts.TomatoSauce>0 and supplyCounts.Cheese>0 then
					--make pizza
					if raw.Mesh.Scale.Y>1.5 then
						if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
						didsomething=true
						network:FireServer("UpdateProperty", raw, "CFrame", CFrame.new(RNG:NextNumber(29.6,44.6),3.7,RNG:NextNumber(42.5,48.5)))
						wait()
						network:FireServer("SquishDough", raw)
					else
						--make sure it will have an oven
						local oven
						for _,o in ipairs(ovens) do
							if isFullyOpen(o) then
								local other = getDoughNear(o.Bottom.Position)
								if other==nil or not (other.BrickColor.Name=="Bright orange" and ffc(other.SG.Frame,"TomatoSauce") and ffc(other.SG.Frame,"MeltedCheese")) then
									if other then
										--replace mistaken dough
										didsomething=true
										if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
										network:FireServer("UpdateProperty", other, "CFrame", CFrame.new(RNG:NextNumber(29.6,44.6),3.7,RNG:NextNumber(42.5,48.5)))
										wait(0.2)
									end
									oven=o
									break
								end
							end
						end
						if oven and raw.Parent==workspace.AllDough then
							--make
							if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
							didsomething=true
							network:FireServer("AddIngredientToPizza", raw,"TomatoSauce")
							network:FireServer("AddIngredientToPizza", raw,"Cheese")
							network:FireServer("AddIngredientToPizza", raw,topping)
							network:FireServer("UpdateProperty", raw, "CFrame", oven.Bottom.CFrame+Vector3.new(0,0.7,0))
							oven.Door.ClickDetector.Detector:FireServer()
							--mark as cooking
							cookingDict[order]=cookingDict[order]+1
							local revoked=false
							spawn(function()
								raw.AncestryChanged:Wait()
								if not revoked then
									cookingDict[order]=cookingDict[order]-1
									revoked=true
								end
							end)
							delay(40, function()
								if not revoked then
									cookingDict[order]=cookingDict[order]-1
									revoked=true
								end
							end)
						end
					end
				end
			end
			--open unnecessarily closed ovens
			for _,o in ipairs(ovens) do
				local bar = o.Door.Meter.SurfaceGui.ProgressBar.Bar
				if o.IsOpen.Value==false and (o.IsCooking.Value==false or (Vector3.new(bar.ImageColor3.r,bar.ImageColor3.g,bar.ImageColor3.b)-Vector3.new(.871,.518,.224)).magnitude>.1) then
					didsomething=true
					if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
					o.Door.ClickDetector.Detector:FireServer()
					break
				end
			end
			--trash
			if badD then
				didsomething=true
				if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
				network:FireServer("UpdateProperty", badD, "CFrame", CFrame.new(RNG:NextNumber(28,30), 1.7, RNG:NextNumber(55,57)))
			end
			if trash and (trash.IsBurned.Value==false or getOvenNear(trash.Position)==nil or getOvenNear(trash.Position).IsOpen.Value) then
				--closed oven breaks if you take burnt out of it
				didsomething=true
				if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.2) end
				network:FireServer("UpdateProperty", trash, "CFrame", CFrame.new(47.90, 7.00, 72.49, 1, 0, -0, 0, 0, 1, 0, -1, 0))
			end
			if didsomething then wait(0.5) else break end
		else
			break
		end
	end
end

while Rayfield.Enabled do
	
	humanoid.Sit = false
	if RNG:NextInteger(1, 20) == 1 then
		game:GetService("VirtualInputManager"):SendKeyEvent(true, "Z", false, game)
		wait()
		game:GetService("VirtualInputManager"):SendKeyEvent(false, "Z", false, game)
	end


	for zz=1,6 do
		local c,order = FindFirstCustomer()
		if doCashier and c and order then
			local reg = 3
			if c.Head.Position.X < 50 then
			    reg = 2
			elseif c.Head.Position.X < 70 then
			    reg = 1
			end
			if (root.Position-Vector3.new(50.30, 3.80, 83.24)).magnitude>9 then smoothTP(CFrame.new(50.30, 3.80, 83.24)) wait(0.2) end
			network:FireServer("OrderComplete", c, order, workspace["Register"..reg])
			wait(0.4)
		else
			break
		end
	end
	tryCook()
	for zz=2,3 do
		if doBoxer then
			local didsomething = false
			local boxP,boxD = FindBoxingFoods()
			local closedBox,openBox,fullBox = FindBoxes()
			if boxD and tick()-boxDtick>0.8 then
				boxDtick=tick()
				didsomething=true
				if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(0.2)  end
				network:FireServer("UpdateProperty", boxD, "CFrame", CFrame.new(63,4.9,-1,-1,0,0,0,1,0,0,0,-1))
			end
			if fullBox then
				if fullBox.Name=="BoxOpen" then
					didsomething=true
					if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(0.2)  end
					network:FireServer("CloseBox", fullBox)
					--will be moved next loop
				elseif tick()-boxPtick>0.8 then
					didsomething=true
					if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(0.2)  end
					network:FireServer("UpdateProperty", fullBox, "CFrame", CFrame.new(68.2,4.4,RNG:NextNumber(-3,-2),-1,0,0,0,1,0,0,0,-1))
					boxPtick=tick()
				end
			end
			if closedBox and not openBox then
				didsomething=true
				if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(0.2)  end
				network:FireServer("UpdateProperty", closedBox, "CFrame", CFrame.new(RNG:NextNumber(62.5,70.5),3.5,RNG:NextNumber(11,25)))
				wait(0.3)
				network:FireServer("OpenBox", closedBox)
			end
			if openBox and boxP then
				didsomething=true
				if (root.Position-Vector3.new(58.74, 3.80, 12.400)).magnitude>9 then  smoothTP(CFrame.new(58.74, 3.80, 12.40))wait(0.1)  end
				network:FireServer("UpdateProperty", boxP, "Anchored", true)
				network:FireServer("UpdateProperty", openBox, "Anchored", true)
				wait(0.4)
				network:FireServer("UpdateProperty", boxP, "CFrame", openBox.CFrame+Vector3.new(0,-2,0))
				wait(0.4)
				network:FireServer("AssignPizzaToBox", openBox, boxP)
			end
			if didsomething then wait(0.7) else break end
		else
			break
		end
	end
	if doDelivery then
		local wstools = FindAllDeliveryTools(workspace)
		if #wstools > 1 or (wstools[1] and ffc(wstools[1].Handle,"X10")) then
			--get tools
			if (root.Position-Vector3.new(54.45, 4.02, -15)).magnitude>9 then smoothTP(CFrame.new(54.45, 4.02, -15)) wait(.1) end
			for i=1,#wstools do
				if wstools[i].Parent == workspace then
					humanoid:EquipTool(wstools[i])
					wait(0.2)
				end
			end
			wait(0.8)
			local t = FindAllDeliveryTools(character)
    		for i=1,#t do
    			t[i].Parent = player.Backpack
    		end
    		wait(0.1)
    		if ffc(character,"RightHand") and ffc(character.RightHand,"RightGrip") then
    			character.RightHand.RightGrip:Destroy()
    		end
		end
		local bptools = FindAllDeliveryTools(player.Backpack)
		if #bptools >= settings.deliver_at and #bptools > 1 and tick()-delTick > 40 then
			--deliver to houses
			table.sort(bptools,function(a,b)
				a,b=tostring(a),tostring(b)
				if (a:sub(1,1)=="B" and b:sub(1,1)=="B") then
					return a < b
				end
				return a > b
			end)
			local fatass=false
			for i=1,#bptools do
				if not doDelivery then
					break
				end
				humanoid.Sit=false
				local tool = bptools[i]
				local giver = getHousePart(tool.Name)
				local ogp = giver.Position
				if giver then
					if (giver.Position-root.Position).Magnitude > 9 then
						smoothTP(giver.CFrame+Vector3.new(0,7,0))
						if giver.Parent==nil or (giver.Position-ogp).Magnitude>1 then
							giver = getHousePart(tool.Name) or giver
							smoothTP(giver.CFrame+Vector3.new(0,7,0))
						end
						pcall(function() tool.Parent = character end)
						wait(1.6)
						local t = FindAllDeliveryTools(character)
                		for i=1,#t do
                		    if t[i] ~= tool then
                			    t[i].Parent = player.Backpack
                			end
                		end
						wait(3)
						fatass=false
					else
						if fatass then
							wait(0.6)
						else
							wait(1.2)
						end
						pcall(function() tool.Parent = character end)
						wait()
						fatass=true
					end
				end
			end
			delTick = tick()
		end
	end
	tryCook()
	if doSupplier then
		local refill=false
		for s,c in pairs(supplyCounts) do
			if c <= settings.refill_at then
				refill=true
				break
			end
		end
		if refill then
			local oldcf = root.CFrame
			local waiting = false
			local waitingTick = 1.8
			local lastBox
			while doSupplier do
				--check if refill is done otherwise hit buttons
				local fulfilled=true
				local boxes = workspace.AllSupplyBoxes:GetChildren()
				for yy=1,9 do
				local needtp=true
				local realc = 0
				for _,btn in ipairs(supplyButtons) do
				    local s = bcolorToSupply[btn.BrickColor.Name]
					if supplyCounts[s] < settings.refill_end then
						local count = 0
						if #boxes > 30 then
							for i=1,#boxes do
								local box = boxes[i]
								if bcolorToSupply[box.BrickColor.Name]==s and box.Anchored==false and box.Position.Z < -940 then
									count=count+1
								end
							end
						end
						if count < 2 then
							if needtp then
							    needtp=false
								smoothTP(btn.CFrame + Vector3.new(0,3,2.5))
								wait(0.5)
							end
							if not doSupplier then break end
							root.CFrame = btn.CFrame + Vector3.new(0,3,0)
							wait(0.3)
							realc=realc+1
						end
						fulfilled=false
					end
				end
				wait(0.3)
				if yy == 1.2 and realc < 3 then
				    wait(0.5)
				end
				end
				if fulfilled or not (doSupplier) then
					break
				end
				smoothTP(CFrame.new(8,12.4,-1020))
				if not doSupplier then break end
				--check if can finish waiting for boxes to move
				if waiting and (lastBox.Position.X>42 or tick()-waitingTick>6) then
					waiting=false
					if lastBox.Position.X<42 then
						--clear boxes if stuck
						smoothTP(CFrame.new(20.5,8,-35))
						wait(0.5)
						local boxes = workspace.AllSupplyBoxes:GetChildren()
						for i=1,#boxes do
							local box = boxes[i]
							if box.Anchored==false and box.Position.Z>-55 then
								network:FireServer("UpdateProperty", box, "CFrame", CFrame.new(RNG:NextNumber(0,40),RNG:NextNumber(-10,-30),-70))
								wait()
							end
						end
						wait(0.2)
					end
				end
				if not waiting then
					--move boxes
					if root.Position.Z > -900 then smoothTP(CFrame.new(8,12.4,-1020)) end
					wait(0.2)
					lastBox=nil
					local j=0
					local boxes = workspace.AllSupplyBoxes:GetChildren()
					for i=1,#boxes do
						local box = boxes[i]
						if box.Anchored==false and box.Position.Z < -940 and bcolorToSupply[box.BrickColor.Name] and supplyCounts[bcolorToSupply[box.BrickColor.Name]]<settings.refill_end then
							box.CFrame = CFrame.new(38-4.3*math.floor(j/2),5,-7-5*(j%2))
							network:FireServer("UpdateProperty", box, "CFrame", box.CFrame)
							lastBox=box
							j=j+1
							if j>13 then break end
						end
					end
					if lastBox then
						waiting=true
						waitingTick=tick()
					end
				end
			end
			--smoothTP(oldcf)
		end
	end
end
