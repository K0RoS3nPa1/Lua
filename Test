local PizzaHub = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
-- Lokale Versionsnummer
local version = "1.0.0"  -- Hier kannst du die Versionsnummer anpassen

-- Textinhalt für das Update mit HTML-ähnlicher Formatierung
local updateContent = string.format([[





Version: %s

- New UI
- Fixed anti TP (carTP)
- Teleport to player dropdown menu
- SaveManager
]], version)



local Window = PizzaHub:CreateWindow({
    Title = "Pizza Hub" .. version ,
    SubTitle = "by Ryuko",
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = true, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Darker",
    MinimizeKey = Enum.KeyCode.Tab -- Used when theres no MinimizeKeybind
})

-- Services
local UIS = game:GetService("UserInputService")
local CG = game:GetService("CoreGui")
local camera = workspace.CurrentCamera

-- Erstelle das runde, mobile GUI
local buttonGui = Instance.new("ScreenGui")
buttonGui.Name = "MobileMinimizeButton"
buttonGui.ResetOnSpawn = false
buttonGui.Parent = CG

-- Runder Button
local button = Instance.new("ImageButton")
button.Size = UDim2.new(0, 60, 0, 60)
button.Position = UDim2.new(0, 300, 0, 300)
button.BackgroundColor3 = Color3.fromRGB(60, 120, 255)
button.Image = "rbxassetid://6034996695" -- Beispiel-Icon
button.BackgroundTransparency = 0
button.AnchorPoint = Vector2.new(0, 0)
button.ZIndex = 10
button.Parent = buttonGui

-- Runde Form
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = button

-- Drag-System (korrekt)
local dragging = false
local dragOffset

button.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		local mousePos = input.Position
		local guiPos = button.AbsolutePosition
		dragOffset = mousePos - guiPos

		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

UIS.InputChanged:Connect(function(input)
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		local newPos = input.Position - dragOffset
		local screenSize = camera.ViewportSize
		local buttonSize = button.AbsoluteSize

		local clampedX = math.clamp(newPos.X, 0, screenSize.X - buttonSize.X)
		local clampedY = math.clamp(newPos.Y, 0, screenSize.Y - buttonSize.Y)

		button.Position = UDim2.new(0, clampedX, 0, clampedY)
	end
end)

-- ✅ Klick = Tab simulieren → Fluent erkennt das automatisch (MinimizeKey = Tab)
button.MouseButton1Click:Connect(function()
	for _, connection in ipairs(getconnections(UIS.InputBegan)) do
		pcall(function()
			connection:Fire({
				UserInputType = Enum.UserInputType.Keyboard,
				KeyCode = Enum.KeyCode.Tab,
				UserInputState = Enum.UserInputState.Begin
			})
		end)
	end
end)


--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Update = Window:AddTab({ Title = "Update", Icon = "star" }),-- für SaveManager / InterfaceManager
    Main = Window:AddTab({ Title = "Main", Icon = "home" }),
    Teleports = Window:AddTab({ Title = "Teleports", Icon = "globe" }),
    Scripts = Window:AddTab({ Title = "Scripts", Icon = "code" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
    
}

-- // MAIN TAB LOGIC BELOW // --



local Options = PizzaHub.Options

    Tabs.Update:AddParagraph({
        Title = updateContent,
        Content = "\n \n \n \n"
    })

--[[
Tabs.Credits:AddParagraph({
    Title = "Credits",
    Content = ""
})

Tabs.Credits:AddButton({
    Title = "Discord Server",
    Description = "Click to copy the Discord server link",
    Callback = function()
        local discordLink = "https://discord.gg/yourserverlink"  -- Hier deinen Discord-Server-Link einfügen
        
        -- Den Link in die Zwischenablage kopieren
        setclipboard(discordLink)
        
        -- Bestätigungsnachricht anzeigen
    end
})
--]]





Tabs.Main:AddToggle("Spam sounds", {
    Title = "Spam sounds",
    Default = false,
    Callback = function(ab)
        getgenv().hit = ab

        -- Wenn der Toggle aktiviert ist, starte den Hintergrund-Loop
        if ab then
            -- Starte den Loop im Hintergrund, um die GUI reaktionsfähig zu halten
            task.spawn(function()
                while getgenv().hit do
                    wait()  -- Warte auf den nächsten Frame

                    -- Iteriere durch alle Sounds im Workspace und spiele sie ab
                    for _, sound in pairs(game.Workspace:GetDescendants()) do
                        if sound:IsA("Sound") then
                            sound:Play()
                        end
                    end
                end
            end)
        end
    end
})

-- Anti Teleport
local player = game.Players.LocalPlayer
local runService = game:GetService("RunService")

local antiTpActive = false
local connection
local lastPosition = nil
local allowedUntil = 0
local lastCarPosition = nil -- Speichern der letzten Fahrzeugposition
local cars = workspace.Cars:GetChildren() -- Alle Fahrzeuge im Workspace

-- Globaler Zugriff auf TP-Freigabe
_G.allowTeleport = function(duration)
    allowedUntil = tick() + (duration or 1.5)
    warn("[TP allowed until]", allowedUntil)
end

-- Globale Teleportfunktion
_G.teleportTo = function(pos)
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")
    if not hrp then return end

    _G.allowTeleport(2)

    if typeof(pos) == "Vector3" then
        hrp.CFrame = CFrame.new(pos)
    elseif typeof(pos) == "CFrame" then
        hrp.CFrame = pos
    end
end

-- Funktion, um zu prüfen, ob der Spieler in einem der Fahrzeuge sitzt
local function isPlayerInAnyVehicle()
    local character = player.Character
    if not character then return nil end
    local humanoid = character:FindFirstChildOfClass("Humanoid")

    -- Prüfen, ob der Spieler in einem Fahrzeug sitzt
    for _, car in ipairs(cars) do
        if humanoid and humanoid.SeatPart and humanoid.SeatPart.Parent == car then
            return car -- Gibt das Fahrzeug zurück, in dem der Spieler sitzt
        end
    end

    return nil -- Kein Fahrzeug gefunden
end

-- Anti-Teleport Toggle
Tabs.Main:AddToggle("AntiTeleport", {
    Title = "Anti-Teleport (carTP)",
    Default = false,
    Callback = function(state)
        antiTpActive = state

        if antiTpActive then
            warn("Anti-TP activated (for all cars)")
            -- Start listening to position changes when Anti-TP is activated
            connection = runService.Heartbeat:Connect(function(_, dt)
                local character = player.Character
                if not character then return end

                local hrp = character:FindFirstChild("HumanoidRootPart")
                if not hrp then return end

                -- Nur aktivieren, wenn der Spieler in einem Fahrzeug sitzt
                local car = isPlayerInAnyVehicle()
                if car then
                    local now = tick()
                    local currentPos = hrp.Position

                    -- Wenn der Spieler im Fahrzeug sitzt, speichern wir seine aktuelle Position
                    if not lastPosition then
                        lastPosition = currentPos
                    end

                    -- Speichern der letzten Fahrzeugposition
                    if not lastCarPosition then
                        lastCarPosition = car.PrimaryPart.Position
                    end

                    local distance = (currentPos - lastPosition).Magnitude

                    -- Wenn die Entfernung größer als 15 ist und der TP nicht erlaubt ist, zurücksetzen
                    if distance > 15 and now > allowedUntil then
                        warn("[Anti-TP] Vehicle teleport detected! Resetting player and car...")

                        -- Setze die Position des Spielers zurück
                        hrp.CFrame = CFrame.new(lastPosition)

                        -- Setze die Fahrzeugposition zurück zur letzten bekannten Position des Spielers
                        car:SetPrimaryPartCFrame(CFrame.new(lastPosition))
                    else
                        -- Update die gespeicherte Position des Spielers
                        lastPosition = currentPos
                        -- Update die gespeicherte Fahrzeugposition
                        lastCarPosition = car.PrimaryPart.Position
                    end
                else
                    -- Wenn der Spieler das Fahrzeug verlässt, zurücksetzen
                    lastPosition = nil
                    lastCarPosition = nil
                end
            end)
        elseif connection then
            -- Verbindung trennen, wenn Anti-TP deaktiviert wird
            connection:Disconnect()
            connection = nil
            warn("Anti-TP disabled")
        end
    end
})





local AntiOvenFireLoop = nil

Tabs.Main:AddToggle("AntiOvenFire", {
    Title = "Anti-Oven Fire",
    Default = false,
    Callback = function(enabled)
        getgenv().heee = enabled

        if enabled then
            AntiOvenFireLoop = task.spawn(function()
                while getgenv().heee do
                    wait(0.4)
                    pcall(function()
                        for _, player in pairs(game.Players:GetPlayers()) do
                            if player.Character and player.Character:FindFirstChild("UpperTorso") then
                                workspace.GameService.ExtinguishFire:FireServer(player.Character.UpperTorso)
                            end
                        end
                        for _, dough in pairs(workspace.AllDough:GetChildren()) do
                            workspace.GameService.ExtinguishFire:FireServer(dough)
                        end
                    end)
                end
            end)
        else
            getgenv().heee = false
            -- `task.spawn` Threads enden automatisch sobald getgenv().heee false ist
        end
    end
})



local RunService = game:GetService("RunService")
local bound = false

Tabs.Main:AddToggle("AntiSit", {
    Title = "Anti sit",
    Default = false,
    Callback = function(enabled)
        if enabled and not bound then
            bound = true
            RunService:BindToRenderStep("AntiSitBinding", Enum.RenderPriority.Camera.Value + 1, function()
                local humanoid = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
                if humanoid and humanoid:GetState() == Enum.HumanoidStateType.Seated then
                    humanoid.Jump = true
                end
            end)
        elseif not enabled and bound then
            RunService:UnbindFromRenderStep("AntiSitBinding")
            bound = false
        end
    end
})

    Tabs.Main:AddToggle("Anti-Moderator", {
        Title = "Anti-Moderator",
        Default = false,
        Callback = function(Enabled)
            local Players = game:GetService("Players")
            local specificUsers = {
               "leosteelo1", "Fixy_7676", "ahhdo", "Googly_Google3",
               "3dCarrot", "overgroundfrom1848", "Phxntomation",
               "Ashbashthesmash", "MicroscopicMay", "Dued1"
            }
            local connection
      
            local function kickWithMessage(modName)
              Players.LocalPlayer:Kick("⚠️ Moderator detected: " .. modName .. " – You have been removed for security reasons.")
              gui = game.CoreGui.RobloxPromptGui.promptOverlay:WaitForChild("ErrorPrompt")  
              gui.TitleFrame.ErrorTitle.Text = "Pizza Hub.." 
              end
      
            local function checkForSpecificUsers(player)
               for _, username in ipairs(specificUsers) do
                  if player.Name == username then
                     kickWithMessage(player.Name)
                  end
               end
            end
      
            if Enabled then
               for _, player in ipairs(Players:GetPlayers()) do
                  checkForSpecificUsers(player)
               end
      
               connection = Players.PlayerAdded:Connect(checkForSpecificUsers)
            else
               if connection then
                  connection:Disconnect()
                  connection = nil
               end
            end
      
        end
    })



local BreakLeaderboardLoop = nil

Tabs.Main:AddToggle("BreakLeaderboard", {
    Title = "Break Leaderboard",
    Default = false,
    Callback = function(z)
        getgenv().nnnnnnnnnnnn = z

        if z then
            BreakLeaderboardLoop = task.spawn(function()
                while getgenv().nnnnnnnnnnnn do
                    wait()
                    pcall(function()
                        local channel = game:GetService("ReplicatedStorage").PlayerChannel
                        local jobs = {
                            "Cashier", "Cook", "Delivery", "Supplier", "On Break",
                            "Cashier", "Cook", "Delivery", "Supplier", "On Break",
                            "Cook", "Delivery", "Cook", "Delivery",
                            "Cashier", "Supplier", "On Break",
                            "Cook", "Delivery", "Supplier", "On Break",
                            "Cook", "Delivery"
                        }

                        for _, job in ipairs(jobs) do
                            channel:FireServer("ChangeJob", job)
                            wait(0.02)
                        end

                        local character = game.Players.LocalPlayer.Character
                        if character then
                            pcall(function() character.Pants:Destroy() end)
                            pcall(function() character.Shirt:Destroy() end)
                        end
                    end)
                end
            end)
        else
            getgenv().nnnnnnnnnnnn = false
            -- Der Loop bricht automatisch ab
        end
    end
})


 Tabs.Main:AddToggle("Kitchen destroyer", {
    Title = "Kitchen destroyer",
    Default = false,
    Callback = function(K)
        _G.cookroomfucker = K
        local lp = game:GetService("Players").LocalPlayer
        local remote
        local ffc = game.FindFirstChild

        if K then
            -- Nur wenn der Nutzer aktiviert!
            local reg = (getreg or debug.getregistry)()
            for i = 1, #reg do
                local f = reg[i]
                if type(f) == "table" and rawget(f, "FireServer") and rawget(f, "BindEvents") then
                    remote = f
                end
            end

            if not remote then
                warn("Remote not found!")
                return
            end

            local function moveThing(bmd, location)
                remote:FireServer("UpdateProperty", bmd, "CFrame", location)
                task.wait()
                remote:FireServer("SquishDough", bmd)
            end

            task.spawn(function()
                while _G.cookroomfucker and task.wait() do
                    for _, list in pairs({
                        workspace.AllDough,
                        workspace.AllMountainDew,
                        workspace.BoxingRoom,
                        workspace.AllBox,
                        workspace.AllSupplyBoxes
                    }) do
                        for _, item in pairs(list:GetChildren()) do
                            moveThing(item, CFrame.new(
                                Random.new():NextNumber(22.6, 51.6),
                                Random.new():NextNumber(3.6, 14.6),
                                Random.new():NextNumber(55.5, 70.5)
                            ))
                        end
                    end
                end
            end)

            task.spawn(function()
                while _G.cookroomfucker and task.wait() do
                    for _, oven in pairs(workspace.Ovens:GetChildren()) do
                        if oven:FindFirstChild("Door") and oven.Door:FindFirstChild("ClickDetector") then
                            oven.Door.ClickDetector.Detector:FireServer()
                            task.wait(0.15)
                        end
                    end
                end
            end)
        end
    end
})


local UnAnchorTreesLoop = nil

Tabs.Main:AddToggle("UnAnchor Trees", {
    Title = "UnAnchor Trees",
    Default = false,
    Callback = function(A)
        getgenv().nhekee = A

        if A then
            UnAnchorTreesLoop = task.spawn(function()
                while getgenv().nhekee do
                    wait(0.50)
                    pcall(function()
                        for _, k in pairs(game.Workspace.Trees:GetDescendants()) do
                            if k.Name == "Tree" or k.Name == "DeadTree" then
                                workspace.Main.UprootTree:FireServer(k)
                            end
                        end
                    end)
                end
            end)
        else
            getgenv().nhekee = false
            -- Der Loop bricht automatisch ab
        end
    end
})

local UnAnchorMailboxesLoop = nil

Tabs.Main:AddToggle("UnAnchor Mailboxes", {
    Title = "UnAnchor Mailboxes",
    Default = false,
    Callback = function(B)
        getgenv().hekee = B

        if B then
            UnAnchorMailboxesLoop = task.spawn(function()
                while getgenv().hekee do
                    wait(1)
                    pcall(function()
                        for _, k in pairs(game.Workspace.Houses:GetDescendants()) do
                            if k.Name == "Mailbox" and k.Parent:IsA("Model") then
                                local g = {[1] = k.Parent}
                                workspace.Main.KnockMailbox:FireServer(unpack(g))
                            end
                        end
                    end)
                end
            end)
        else
            getgenv().hekee = false
            -- Der Loop bricht automatisch ab
        end
    end
})

    
    local Slider = Tabs.Main:AddSlider("Walkspeed", {
        Title = "Walkspeed",
        Description = "",
        Default = 16,
        Min = 16,
        Max = 100,
        Rounding = 1,
        Callback = function(W)
            game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = W
        end
    })
    local Slider = Tabs.Main:AddSlider("Jumppower", {
        Title = "Jumppower",
        Description = "",
        Default = 50,
        Min = 50,
        Max = 500,
        Rounding = 1,
        Callback = function(J)
            game.Players.LocalPlayer.Character.Humanoid.JumpPower = J
        end
    })


--[Teleports]--
local player = game.Players.LocalPlayer
local displayToUsername = {}
local dropdownRef

-- Spieler abrufen
local function getPlayerDisplayNames()
    local entries = { "None" }
    displayToUsername = {}

    for _, p in ipairs(game.Players:GetPlayers()) do
        if p ~= player then
            local display = string.format("%s (%s)", p.DisplayName, p.Name)
            table.insert(entries, display)
            displayToUsername[display] = p.Name
        end
    end

    table.sort(entries)
    return entries
end

-- Teleportfunktion
local function teleportToPlayerDisplay(displayName)
    local username = displayToUsername[displayName]
    if not username then
       
        return
    end

    local target = game.Players:FindFirstChild(username)
    if target and target.Character then
        local hrp = target.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local myChar = player.Character or player.CharacterAdded:Wait()
            local myHRP = myChar:WaitForChild("HumanoidRootPart")
            myHRP.CFrame = hrp.CFrame
         
        else
         
        end
    else
       
    end
end

-- Dropdown erstellen
local function createDropdown()
    local values = getPlayerDisplayNames()

    dropdownRef = Tabs.Teleports:AddDropdown("TeleportToPlayer", {
        Title = "Teleport to player",
        Values = values,
        Default = "None",
        Multi = false,
        Callback = function(selected)
            if typeof(selected) ~= "string" then
               
                return
            end

            if selected == "None" then
                
                return
            end

            -- Noch mal prüfen ob der ausgewählte Spieler existiert
            if not displayToUsername[selected] then
               
                return
            end

            teleportToPlayerDisplay(selected)
        end
    })
end

-- Dropdown aktualisieren
local function updateDropdown()
    if not dropdownRef then return end
    local newValues = getPlayerDisplayNames()
    dropdownRef:SetValues(newValues)

    -- Wenn der aktuelle Wert ungültig ist, zurücksetzen
    if not table.find(newValues, dropdownRef.Value) then
        dropdownRef:SetValue("None")
    end
end

-- Spieler join/leave Events
game.Players.PlayerAdded:Connect(updateDropdown)
game.Players.PlayerRemoving:Connect(updateDropdown)

-- Automatische Aktualisierung
task.spawn(function()
    while true do
        task.wait(5)
        updateDropdown()
    end
end)

-- Start
createDropdown()


-- Bereichsteleport Dropdown
Tabs.Teleports:AddDropdown("TeleportArea", {
    Title = "Teleport to area",
    Values = { "None", "Spawn", "Manager", "Cashier", "Cook", "Boxer", "Delivery", "Supplier" },
    Multi = false,
    Default = "None",
    Callback = function(option)
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        if not hrp then return end

        local locations = {
            Spawn = Vector3.new(49, 3, 198),
            Manager = Vector3.new(37, 4, 3),
            Cashier = Vector3.new(48, 4, 80),
            Cook = Vector3.new(42, 4, 61),
            Boxer = Vector3.new(55, 4, 31),
            Delivery = Vector3.new(64, 4, -17),
            Supplier = Vector3.new(8, 13, -1020)
        }

        if locations[option] then
            hrp.CFrame = CFrame.new(locations[option])
        end
    end
})


-- Haus-Teleport Dropdown
Tabs.Teleports:AddDropdown("TeleportHouse", {
    Title = "Teleport to house",
    Values = { "None", "Home", "A1", "A2", "A3", "B1", "B2", "B3", "B4", "B5", "B6", "C1", "C2", "C3" },
    Multi = false,
    Default = "None",
    Callback = function(option)
        local character = player.Character or player.CharacterAdded:Wait()
        local hrp = character:WaitForChild("HumanoidRootPart")
        if not hrp then return end

        local coords = {
            A1 = Vector3.new(190, 3, -474),
            A2 = Vector3.new(188, 3, -652),
            A3 = Vector3.new(187, 3, -823),
            B1 = Vector3.new(-21, 3, -432),
            B2 = Vector3.new(24, 3, -481),
            B3 = Vector3.new(-20, 3, -612),
            B4 = Vector3.new(24, 3, -663),
            B5 = Vector3.new(-20, 3, -800),
            B6 = Vector3.new(23, 3, -836),
            C1 = Vector3.new(-184, 3, -444),
            C2 = Vector3.new(-186, 3, -612),
            C3 = Vector3.new(-185, 3, -792)
        }

        if option == "Home" then
            game:GetService("ReplicatedStorage").PlayerChannel:FireServer("TeleportHome")
        elseif coords[option] then
            hrp.CFrame = CFrame.new(coords[option])
        end
    end
})


-- Insel-Teleport Dropdown
local player = game.Players.LocalPlayer

Tabs.Teleports:AddDropdown("TeleportIslands", {
    Title = "Teleport to island",
    Values = { "None", "Pirate Island", "Stone Island", "Sand Island", "Teleport to Party Island" },
    Multi = false,
    Default = "None",
    Callback = function(option)
        local islandModelName = {
            ["Pirate Island"] = "Island",
            ["Stone Island"] = "Island1",
            ["Sand Island"] = "Island2"
        }
    
        if islandModelName[option] then
            local model = workspace:FindFirstChild(islandModelName[option])
            if model and model:IsA("Model") then
                local targetCFrame = model:GetPivot() + Vector3.new(0, 20, 0)
                _G.teleportTo(targetCFrame)
            else
            end
        elseif option == "Teleport to Party Island" then
            _G.teleportTo(Vector3.new(88, 1, -315))
        elseif option == "None" then
        end
    end    
})



Tabs.Scripts:AddButton({
    Title = "Autofarm",
    Description = "pls use alts!",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/K0RoS3nPa1/Lua/refs/heads/main/lua2"))()
    end
})


-- Pizza Place Script Button
Tabs.Scripts:AddButton({
    Title = "Work at a pizza place",
    Description = "Hussien",
    Callback = function()
        loadstring(game:HttpGet(('https://raw.githubusercontent.com/Hm5011/hussain/refs/heads/main/Work%20at%20a%20pizza%20place'),true))()
    end
})

-- Infinite Yield Button
Tabs.Scripts:AddButton({
    Title = "Infinite Yield",
    Description = "",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
    end
})






-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(PizzaHub)
InterfaceManager:SetLibrary(PizzaHub)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("PizzaHub/Hub settings")
SaveManager:SetFolder("PizzaHub/game settings")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)


PizzaHub:Notify({
    Title = "Pizza Hub",
    Content = "The script has been loaded.",
    Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()

