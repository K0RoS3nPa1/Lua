-- Lade Rayfield von der richtigen Quelle
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

if not Rayfield then
error("Rayfield konnte nicht geladen werden. Überprüfe die URL.")
end

local doCashier,doBoxer,doCook,doSupplier,doDelivery = false,false,false,false,false


-- GUI Info-Anzeige
Rayfield:Notify({
    Title = "Info",
    Content = "GUI wird geladen...",
    Duration = 3
})

-- Erstelle das Hauptfenster für Rayfield
local window = Rayfield:CreateWindow({
    Name = "Pizza Factory Mod",
    LoadingTitle = "Lädt...",
    LoadingSubtitle = "Bitte warten",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "PizzaFactorySettings",
        FileName = "PizzaFactory"
    },
    Discord = {
        Enabled = false,
        Invite = ""
    },
    KeySystem = false
})


local settings = {refill_at=50, refill_end=97, movespeed_at=5, deliver_at=5, stay_in_kitchen=true}
local player = game:GetService("Players").LocalPlayer
local ffc = game.FindFirstChild
local RNG = Random.new()
local network
local character,root,humanoid
do
	local reg = (getreg or debug.getregistry)()
	for i=1,#reg do
		local f = reg[i]
		if type(f)=="function" then
		    for k,v in next,getupvalues(f) do
				if typeof(v)=="Instance" then
				    if v.Name=="CashOut" then
						wait(0.2)
					    setupvalue(f,k,{MouseButton1Click={wait=function()end,Wait=function()end}})
				    elseif v.Name=="StickerName" then
				        setupvalue(f,k,nil)
				    end
				end
			end
    		if tostring(getfenv(f)) .. tostring(script) == "Music" then

    		    local consts = getconstants(f)
    		    local loc=false
		        for ci,c in next,consts do
		            if c == "location changed" then
		                loc=true
		            elseif loc and c == "SendData" then
		                setconstant(f,ci,"ExplodeString")
		                break
		            end
		        end
    		end
		elseif type(f)=="table" and rawget(f,"FireServer") and rawget(f,"BindEvents") then
			network = f
		end
	end
end

--//subroutines
local supplyCounts = {TomatoSauce=99,Cheese=99,Sausage=99,Pepperoni=99,Dough=99,Box=99,Dew=99}
for name in pairs(supplyCounts) do
	local lbl = workspace.SupplyCounters.Model[name=="Dew" and "CounterMountainDew" or "Counter"..name].a.SG.Counter
	supplyCounts[name]=tonumber(lbl.Text)
	lbl.Changed:Connect(function()
		supplyCounts[name]=tonumber(lbl.Text)
	end)
end

local function FindFirstCustomer()

	local children = workspace.Customers:GetChildren()
	for i=1,#children do
		local c = children[i] 
		if ffc(c,"Head") and ffc(c,"Humanoid") and c.Head.CFrame.Z<102 and ffc(c.Head,"Dialog") and ffc(c.Head.Dialog,"Correct") and ((c.Humanoid.SeatPart and c.Humanoid.SeatPart.Anchored) or (c.Humanoid.SeatPart==nil and (c.Head.Velocity.Z^2)^.5<.0001)) then
			local dialog = c.Head.Dialog.Correct.ResponseDialog or ''
			local order = "MountainDew"
			if dialog:sub(-30)=="instead." then
				dialog = dialog:sub(-30)
			end
			if dialog:find("pepperoni",1,true) then
				order = "PepperoniPizza"
			elseif dialog:find("sausage",1,true) then
				order = "SausagePizza"
			elseif dialog:find("cheese",1,true) then
				order = "CheesePizza"
			end
			return c,order
		end
	end
end

local boxPtick=0
local boxDtick=0
local function FindBoxes()
	local c,o,f
	local children = workspace.AllBox:GetChildren()
	for i=1,#children do
		local b = children[i]
		if ffc(b,"HasPizzaInside") or ffc(b,"Pizza") then
			if c==nil and b.Name=="BoxClosed" and b.Anchored==false and not b.HasPizzaInside.Value then
				c=b
			elseif o==nil and b.Name=="BoxOpen" and b.Anchored==false and not b.Pizza.Value then
				o=b
			elseif f==nil and (b.Name=="BoxOpen" and b.Pizza.Value) or (b.Name=="BoxClosed" and b.HasPizzaInside.Value) then
				f=b
			end
			if c and o and f then
				return c,o,f
			end
		end
	end
	return c,o,f
end
local function FindBoxingFoods()
	local p,d
	local children = workspace.BoxingRoom:GetChildren()
	for i=1,#children do
		local f = children[i]
		if not f.Anchored then
			if p==nil and f.Name=="Pizza" then
				p=f
			elseif d==nil and f.Name=="Dew" then
				d=f
			end
			if p and d then
				return p,d
			end
		end
	end
	return p,d
end

local orderDict={["3540529228"]="Cheese",["3540530535"]="Sausage",["3540529917"]="Pepperoni",["2512571151"]="Dew",["2512441325"]="Dew",["11874352009"]="Dew"}
local cookingDict = {Cheese=0,Sausage=0,Pepperoni=0,Dew=0}
local cookPtick=0
local cookDtick=0
local cookWarned=false
local boxerWarned=false
local function getOrders()
	local orders={}
	local tempCookingDict = {}
	for i,v in pairs(cookingDict) do tempCookingDict[i]=v end
	local children = workspace.Orders:GetChildren()
	for i=1,#children do
		local o = orderDict[children[i].SG.ImageLabel.Image:match("%d+$")]
		if o then
			if tempCookingDict[o]>0 then
				--ignores oven pizzas, so new orders are priority
				tempCookingDict[o]=tempCookingDict[o]-1
			elseif (o=="Dew" and #workspace.AllMountainDew:GetChildren()>0) or (supplyCounts[o]>0 and supplyCounts.TomatoSauce>0 and supplyCounts.Cheese>0) then
				--need supplies
				orders[#orders+1]=o
			end
		end
	end
	return orders
end
local function FindFirstDew()
	local children = workspace.AllMountainDew:GetChildren()
	for i=1,#children do
		local d = children[i]
		if (ffc(d,"IsBurned")==nil or d.IsBurned.Value==false) and not d.Anchored then
			return d
		end
	end
end
local function FindBadDew()
	local children = workspace.AllMountainDew:GetChildren()
	for i=1,#children do
		local d = children[i]
		if (ffc(d,"IsBurned")==nil or d.IsBurned.Value==false) and d.Position.X > 53 and d.Position.Z > 50 and not d.Anchored then
			return d
		end
	end
end
local function FindDoughAndWithout(str)
	local goodraw,p,raw,trash
	local children = workspace.AllDough:GetChildren()
	for i = #children, 2, -1 do --shuffle
		local j = RNG:NextInteger(1, i)
		children[j], children[i] = children[i], children[j]
	end
	for i=1,#children do
		local d = children[i]
		if d.Anchored==false and #d:GetChildren()>9 then
			if d.IsBurned.Value or d.HasBugs.Value or d.Cold.Value or (d.BrickColor.Name=="Bright orange" and ffc(d,"XBillboard")) then
				if trash==nil and d.Position.Y > 0 and ((d.Position*Vector3.new(1,0,1))-Vector3.new(47.90, 0, 72.49)).Magnitude > 1 then
					trash=d
				end
			elseif p==nil and d.BrickColor.Name=="Bright orange" then
				p=d
			elseif goodraw==nil and d.Position.X<55 and d.BrickColor.Name=="Brick yellow" and ((str and not ffc(d.SG.Frame,str)) or (str==nil and ffc(d.SG.Frame,"Sausage")==nil and ffc(d.SG.Frame,"Pepperoni")==nil)) then
				--prefers flat
				if d.Mesh.Scale.Y<1.1 then
					goodraw=d
				else
					raw=d
				end
			end
			if goodraw and p and trash then
				return goodraw,p,trash
			end
		end
	end
	return goodraw or raw,p,trash
end
local function getOvenNear(pos)
	local children = workspace.Ovens:GetChildren()
	for i=1,#children do
		if ffc(children[i],"Bottom") and (children[i].Bottom.Position-pos).magnitude < 1.5 then
			return children[i]
		end
	end
end
local function getDoughNear(pos)
	local children = workspace.AllDough:GetChildren()
	for i=1,#children do
		if (children[i].Position-pos).magnitude < 1.5 then
			return children[i]
		end
	end
end
local function isFullyOpen(oven)
	return oven.IsOpen.Value==true and (oven.Door.Meter.RotVelocity.Z^2)^.5<.0001
end

local bcolorToSupply = {["Dark orange"]="Sausage",["Bright blue"]="Pepperoni",["Bright yellow"]="Cheese",["Bright red"]="TomatoSauce",["Dark green"]="Dew",["Brick yellow"]="Dough",["Light stone grey"]="Box",["Really black"]="Dew",["Navy blue"]="Dew"}
local supplyButtons = {}
for i,v in ipairs(workspace.SupplyButtons:GetChildren()) do
	supplyButtons[i] = v.Unpressed
end
table.sort(supplyButtons,function(a,b) return a.Position.X < b.Position.X end)
local delTick = 0
local function FindAllDeliveryTools(parent)
	local t = {}
	local children = parent:GetChildren()
	for i=1,#children do
		local v = children[i]
		if v.ClassName=="Tool" and v.Name:match("^%u%d$") and ffc(v,"Handle") and ffc(v,"House") and (parent~=workspace or (v.Handle.Position-Vector3.new(54.45, 4.02, -16.56)).Magnitude < 30) then
			t[#t+1] = v
		end
	end
	return t
end
local function getHousePart(address)
    local houses = workspace.Houses:GetChildren()
    for i=1,#houses do
        local h = houses[i]
        if ffc(h,"Address") and h.Address.Value==address and ffc(h,"GivePizza",true) then
            return ffc(h,"GivePizza",true)
        end
    end
end
local function onCharacterAdded(char)
	if not char then return end
	character=char
	root = character:WaitForChild("HumanoidRootPart")
	humanoid = character:WaitForChild("Humanoid")
	humanoid:SetStateEnabled("FallingDown",false)
end
onCharacterAdded(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterAdded)

local function smoothTP2(cf)
	local cf0 = (cf-cf.p) + root.Position + Vector3.new(0,0,0)
	local diff = cf.p - root.Position
	local oldg = workspace.Gravity
	workspace.Gravity = 197
	for i=0,diff.Magnitude,settings.movespeed_at do
		humanoid.Sit=false
		root.CFrame = cf0 + diff.Unit * i
		root.Velocity,root.RotVelocity=Vector3.new(),Vector3.new()
		wait()
	end
	root.CFrame = cf
	workspace.Gravity = oldg
end
local function smoothTP(cf)
    if (cf.p-root.Position).Magnitude > 97 then
        local btns = workspace.JobButtons:GetChildren()
        if player:FindFirstChild("House") and player.House.Value then
            btns[#btns+1] = player.House.Value:FindFirstChild("Marker") 
        end
        table.sort(btns,function(a,b) return (a.Position-cf.p).Magnitude < (b.Position-cf.p).Magnitude end)
        if (btns[1].Position-cf.p).Magnitude < (cf.p-root.Position).Magnitude then
            game:GetService("ReplicatedStorage").PlayerChannel:FireServer("TeleportToJob", ((btns[1].Name == "Marker") and "House" or btns[1].Name))
            wait(0.9)
            if (cf.p-root.Position).Magnitude < 9 then
                return
            end
        end
    end
    smoothTP2(cf)
end
for _,o in ipairs(workspace.Ovens:GetChildren()) do
	if ffc(o,"Bottom") then
		o.Bottom.CanTouch = false
	end
end
local function tryCook()
	for zz=1,38 do
		local order = getOrders()[1]
		local topping
		if order=="Pepperoni" or order=="Sausage" then topping=order end
		local cookD = FindFirstDew()
		local badD = FindBadDew()
		local cookP,trash
		local raw = workspace.AllDough:FindFirstChildOfClass("BasePart") -- Nimmt das nächste Dough, falls vorhanden
		if not raw then return end
		if topping then
			--pepperoni order avoids sausage dough and vice verca
			raw,cookP,trash = FindDoughAndWithout(topping=="Pepperoni" and "Sausage" or "Pepperoni")
		else
			raw,cookP,trash = FindDoughAndWithout()
		end
		local ovens = workspace.Ovens:GetChildren()
		for i=#ovens,1,-1 do
		    if #ovens[i]:GetChildren() < 10 then
		        table.remove(ovens,i)
		    end
		end
		for i = #ovens, 2, -1 do --shuffle
			local j = RNG:NextInteger(1, i)
			ovens[j], ovens[i] = ovens[i], ovens[j]
		end
		if doCook then
			local didsomething=false
			--move final pizza
			if cookP and tick()-cookPtick>0.8 then
				local oven = getOvenNear(cookP.Position)
				if oven==nil or oven.IsOpen.Value then
					cookPtick=tick()
					didsomething=true
					if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.1) end
					network:FireServer("UpdateProperty", cookP, "CFrame", CFrame.new(RNG:NextNumber(56,57),4.1,38))
				end
			end
			if order then
				if order=="Dew" and cookD and tick()-cookDtick>0.8 then
					--move dew if ordered
					cookDtick=tick()
					didsomething=true
					if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.1) end
					network:FireServer("UpdateProperty", cookD, "CFrame", CFrame.new(53,4.68,36.5))
				elseif order~="Dew" and raw and raw.Parent and supplyCounts[order]>0 and supplyCounts.TomatoSauce>0 and supplyCounts.Cheese>0 then
					--make pizza
					if raw.Mesh.Scale.Y>1.5 then
						if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(.1) end
						didsomething=true
						network:FireServer("UpdateProperty", raw, "CFrame", CFrame.new(RNG:NextNumber(29.6,44.6),3.7,RNG:NextNumber(42.5,48.5)))
						wait()
						network:FireServer("SquishDough", raw)
					else
						--make sure it will have an oven
						local oven
						for _,o in ipairs(ovens) do
							if isFullyOpen(o) then
								local other = getDoughNear(o.Bottom.Position)
								if other==nil or not (other.BrickColor.Name=="Bright orange" and ffc(other.SG.Frame,"TomatoSauce") and ffc(other.SG.Frame,"MeltedCheese")) then
									if other then
										--replace mistaken dough
										didsomething=true
										if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.1) end
										network:FireServer("UpdateProperty", other, "CFrame", CFrame.new(RNG:NextNumber(29.6,44.6),3.7,RNG:NextNumber(42.5,48.5)))
										wait()
									end
									oven=o
									break
								end
							end
						end
						if oven and raw.Parent == workspace.AllDough then
							-- Sicherstellen, dass der Ofen und der Teig im AllDough-Bereich vorhanden sind
							-- `oven` muss existieren und `raw.Parent` muss im `AllDough` Bereich sein (der Bereich, wo der Teig liegt)
						
							-- Überprüfen, ob der Teig sich nicht an der Zielposition befindet
							-- Wenn der Teig zu weit entfernt ist, teleportieren wir ihn zu der Zielposition (36.64, 3.80, 54.11)
							if (root.Position - Vector3.new(36.64, 3.80, 54.11)).magnitude > 9 then
								smoothTP(CFrame.new(36.64, 3.80, 54.11))  -- Teleportiere den Teig zur Zielposition
								wait(0.3)  -- Kurze Pause, um sicherzustellen, dass der Teig korrekt teleportiert wurde
							end
						
							-- Setze eine Flagge auf true, um anzugeben, dass etwas passiert ist
							didsomething = true
						
							-- Füge die Zutaten zum Teig hinzu:
							network:FireServer("AddIngredientToPizza", raw, "TomatoSauce")  -- Tomatensauce wird hinzugefügt
							wait(0.1)  -- Kurze Pause zwischen den Zutaten
							network:FireServer("AddIngredientToPizza", raw, "Cheese")  -- Käse wird hinzugefügt
							wait(0.2)  -- Kurze Pause, bevor die nächste Zutat hinzugefügt wird
							network:FireServer("AddIngredientToPizza", raw, topping)  -- Die spezifische Zutat (z.B. Pepperoni) wird hinzugefügt
						
							-- Bewege den Teig in den Ofen:
							-- Der Teig wird an die Position des Ofens verschoben, leicht über dem Boden des Ofens (0,7 Einheiten höher)
							network:FireServer("UpdateProperty", raw, "CFrame", oven.Bottom.CFrame + Vector3.new(0, 0.7, 0))
						
							-- Öffne die Ofentür, um den Teig hineinzulegen
							oven.Door.ClickDetector.Detector:FireServer()  -- Simuliere den Klick auf die Ofentür, um den Teig hineinzulegen
						
						
						cookingDict[order]=cookingDict[order]+1
						local revoked=false
						spawn(function()
							raw.AncestryChanged:Wait()
							if not revoked then
								cookingDict[order]=cookingDict[order]-1
								revoked=true
							end
						end)
						delay(40, function()
							if not revoked then
								cookingDict[order]=cookingDict[order]-1
								revoked=true
							end
						end)
					end
				end
			end
		end
		--open unnecessarily closed ovens
		for _,o in ipairs(ovens) do
			local bar = o.Door.Meter.SurfaceGui.ProgressBar.Bar
			if o.IsOpen.Value==false and (o.IsCooking.Value==false or (Vector3.new(bar.ImageColor3.r,bar.ImageColor3.g,bar.ImageColor3.b)-Vector3.new(.871,.518,.224)).magnitude>.1) then
				didsomething=true
				if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.1) end
				o.Door.ClickDetector.Detector:FireServer()
				break
			end
		end
		--trash
		if badD then
			didsomething=true
			if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.1) end
			network:FireServer("UpdateProperty", badD, "CFrame", CFrame.new(RNG:NextNumber(28,30), 1.7, RNG:NextNumber(55,57)))
		end
		if trash and (trash.IsBurned.Value==false or getOvenNear(trash.Position)==nil or getOvenNear(trash.Position).IsOpen.Value) then
			--closed oven breaks if you take burnt out of it
			didsomething=true
			if (root.Position-Vector3.new(36.64, 3.80, 54.11)).magnitude>9 then  smoothTP(CFrame.new(36.64, 3.80, 54.11)) wait(0.1) end
			network:FireServer("UpdateProperty", trash, "CFrame", CFrame.new(47.90, 7.00, 72.49, 1, 0, -0, 0, 0, 1, 0, -1, 0))
		end
		if didsomething then wait(0.5) else break end
	else
		break
	end
end
end



-- Hauptschleife, die auf den Status von loopEnabled reagiert
local loopEnabled = false
local loopThread = nil -- Speichert den Thread der Schleife
local part = workspace:FindFirstChild("Computer")
-- Funktion, um die Schleife zu starten
local function startLoop()
    if loopThread then return end -- Verhindere, dass mehrere Threads gestartet werden

    loopThread = spawn(function()
        while loopEnabled do
			if humanoid.Health <= 0 then
                print("Spieler ist tot. Schleife pausiert.")
                loopEnabled = false
                loopThread = nil
                return
            end
	if humanoid and humanoid.Sit then
		humanoid.Sit = false
	end

	if part and part.Parent == workspace then
		part.Parent = nil -- Entfernt das Objekt aus Workspace
	end

	if RNG:NextInteger(1,20)==1 then
        game:GetService("VirtualInputManager"):SendKeyEvent(true,"Z",false,game)
        wait()
        game:GetService("VirtualInputManager"):SendKeyEvent(false,"Z",false,game)
	end
	for zz = 1,9 do  -- Wiederhole den Vorgang 6 Mal
		local c, order = FindFirstCustomer()  -- Finde den ersten Kunden und seine Bestellung
		if doCashier and c and order then  -- Wenn der Kassierer-Modus aktiviert ist und ein Kunde sowie eine Bestellung vorhanden sind
			local reg = 3  -- Setze den Standard-Registerwert auf 3
			if c.Head.Position.X < 50 then  -- Wenn der Kunde sich links des Registers befindet
				reg = 2  -- Setze das Register auf 2
			elseif c.Head.Position.X < 70 then  -- Wenn der Kunde sich in der Nähe von Register 1 befindet
				reg = 1  -- Setze das Register auf 1
			end
			
			if (root.Position - Vector3.new(50.30, 3.80, 83.24)).magnitude > 9 then  -- Wenn der Spieler zu weit von der Position des Registers entfernt ist
				smoothTP(CFrame.new(50.30, 3.80, 83.24))  -- Teleportiere den Spieler zur Position des Registers
				wait(0.2)  -- Warte eine kurze Zeit
			end
	
			-- Markiere die Bestellung des Kunden als abgeschlossen und aktualisiere das entsprechende Register
			network:FireServer("OrderComplete", c, order, workspace["Register"..reg])
			wait(0.4)  -- Warte 0.4 Sekunden, um den nächsten Schritt vorzubereiten
		else
			break  -- Wenn kein Kunde oder keine Bestellung vorhanden ist, beende die Schleife
		end
	end
	
	wait(2)
	tryCook()
	for zz = 2,9 do  -- Wiederhole den Vorgang von 2 bis 7, was bedeutet, dass dieser Block 6 Mal durchlaufen wird
		if doBoxer then  -- Wenn der Boxer-Modus aktiviert ist
			local didsomething = false  -- Flagge, um zu prüfen, ob eine Aktion ausgeführt wurde
			local boxP, boxD = FindBoxingFoods()  -- Finde Boxen, die zum Verpacken der Lebensmittel verwendet werden
			local closedBox, openBox, fullBox = FindBoxes()  -- Finde geschlossene, offene und volle Boxen
			
			if boxD and tick() - boxDtick > 0.8 then  -- Wenn eine Box zum Verpacken gefunden wurde und eine bestimmte Zeit vergangen ist
				boxDtick = tick()  -- Setze die Zeit des letzten Tick auf den aktuellen Zeitpunkt
				didsomething = true  -- Setze didsomething auf true, da etwas getan wurde
				if (root.Position - Vector3.new(58.74, 3.80, 12.400)).magnitude > 9 then
					-- Wenn der Spieler zu weit von der Position entfernt ist, teleportiere ihn dorthin
					smoothTP(CFrame.new(58.74, 3.80, 12.40)) 
					wait(0.2)  -- Warte eine kurze Zeit
				end
				-- Aktualisiere die Position der Box
				network:FireServer("UpdateProperty", boxD, "CFrame", CFrame.new(63, 4.9, -1, -1, 0, 0, 0, 1, 0, 0, 0, -1))
			end
	
			if fullBox then  -- Wenn eine volle Box vorhanden ist
				if fullBox.Name == "BoxOpen" then  -- Wenn es sich um eine offene Box handelt
					didsomething = true  -- Setze didsomething auf true
					if (root.Position - Vector3.new(58.74, 3.80, 12.400)).magnitude > 9 then
						-- Teleportiere den Spieler zur Position der offenen Box, wenn er zu weit entfernt ist
						smoothTP(CFrame.new(58.74, 3.80, 12.40)) 
						wait(0.2)
					end
					-- Schließe die offene Box
					network:FireServer("CloseBox", fullBox)
					-- Die Box wird im nächsten Loop verschoben
				elseif tick() - boxPtick > 0.8 then  -- Wenn mehr als 0.8 Sekunden vergangen sind
					didsomething = true  -- Setze didsomething auf true
					if (root.Position - Vector3.new(58.74, 3.80, 12.400)).magnitude > 9 then
						-- Teleportiere den Spieler zur Box, wenn er zu weit entfernt ist
						smoothTP(CFrame.new(58.74, 3.80, 12.40))
						wait(0.2)
					end
					-- Aktualisiere die Position der vollen Box
					network:FireServer("UpdateProperty", fullBox, "CFrame", CFrame.new(68.2, 4.4, RNG:NextNumber(-3, -2), -1, 0, 0, 0, 1, 0, 0, 0, -1))
					boxPtick = tick()  -- Setze den Zeitpunkt des letzten Ticks
				end
			end
	
			if closedBox and not openBox then  -- Wenn eine geschlossene Box vorhanden ist und keine offene Box existiert
				didsomething = true  -- Setze didsomething auf true
				if (root.Position - Vector3.new(58.74, 3.80, 12.400)).magnitude > 9 then
					-- Teleportiere den Spieler zur geschlossenen Box, wenn er zu weit entfernt ist
					smoothTP(CFrame.new(58.74, 3.80, 12.40))
					wait(0.2)
				end
				-- Aktualisiere die Position der geschlossenen Box
				network:FireServer("UpdateProperty", closedBox, "CFrame", CFrame.new(RNG:NextNumber(62.5, 70.5), 3.5, RNG:NextNumber(11, 25)))
				wait(0.3)  -- Warte eine kurze Zeit
				-- Öffne die geschlossene Box
				network:FireServer("OpenBox", closedBox)
			end
	
			if openBox and boxP then  -- Wenn eine offene Box und eine Pizza-Box vorhanden sind
				didsomething = true  -- Setze didsomething auf true
				if (root.Position - Vector3.new(58.74, 3.80, 12.400)).magnitude > 9 then
					-- Teleportiere den Spieler zur offenen Box, wenn er zu weit entfernt ist
					smoothTP(CFrame.new(58.74, 3.80, 12.40)) 
					wait(0.1)
				end
				-- Aktualisiere die Position der Pizza-Box und der offenen Box
				network:FireServer("UpdateProperty", boxP, "Anchored", true)
				network:FireServer("UpdateProperty", openBox, "Anchored", true)
				wait(0.4)
				-- Verschiebe die Pizza-Box in die offene Box
				network:FireServer("UpdateProperty", boxP, "CFrame", openBox.CFrame + Vector3.new(0, -2, 0))
				wait(0.6)
				-- Weise die Pizza der offenen Box zu
				network:FireServer("AssignPizzaToBox", openBox, boxP)
			end
	
			if didsomething then 
				wait(0.7)  -- Wenn eine Aktion ausgeführt wurde, warte 0.7 Sekunden
			else 
				break  -- Wenn keine Aktion ausgeführt wurde, beende die Schleife
			end
		else
			break  -- Beende die Schleife, wenn der Boxer-Modus deaktiviert ist
		end
	end
	
	if doDelivery then  -- Wenn der Delivery-Modus aktiviert ist
		local wstools = FindAllDeliveryTools(workspace)  -- Finde alle Werkzeuge für die Lieferung im Workspace
	
		-- Überprüfe, ob mehr als ein Werkzeug im Workspace ist oder ob das erste Werkzeug ein spezielles Attribut hat ("X10")
		if #wstools > 1 or (wstools[1] and ffc(wstools[1].Handle,"X10")) then
			-- Holen der Werkzeuge
			if (root.Position - Vector3.new(54.45, 4.02, -15)).magnitude > 9 then 
				-- Wenn der Spieler zu weit vom Zielpunkt entfernt ist, teleportiere den Spieler
				smoothTP(CFrame.new(54.45, 4.02, -15)) 
				wait(0.1)  -- Kurze Wartezeit
			end
	
			-- Gehe durch jedes Werkzeug im Workspace und rüste den Spieler damit aus
			for i = 1, #wstools do
				if wstools[i].Parent == workspace then
					humanoid:EquipTool(wstools[i])  -- Rüste den Spieler mit dem Werkzeug aus
					wait(0.2)  -- Warte eine kurze Zeit, um sicherzustellen, dass der Spieler das Werkzeug erhalten hat
				end
			end
			wait(0.9)  -- Warte eine weitere kurze Zeit, um sicherzustellen, dass der Spieler bereit ist
	
			-- Finde alle Werkzeuge im Inventar des Spielers (Character)
			local t = FindAllDeliveryTools(character)
			-- Verschiebe die Werkzeuge von Character zurück in den Rucksack
			for i = 1, #t do
				t[i].Parent = player.Backpack
			end
			wait(0.2)  -- Kurze Wartezeit
	
			-- Wenn der Charakter das RightHand hat und RightGrip vorhanden ist, zerstöre es
			if ffc(character, "RightHand") and ffc(character.RightHand, "RightGrip") then
				character.RightHand.RightGrip:Destroy()
			end
		end
	
		-- Hole alle Werkzeuge aus dem Rucksack des Spielers
		local bptools = FindAllDeliveryTools(player.Backpack)
		
		-- Überprüfe, ob genügend Werkzeuge vorhanden sind und ob mehr als 40 Sekunden vergangen sind
		if #bptools >= settings.deliver_at and #bptools > 1 and tick() - delTick > 40 then
			-- Sortiere die Werkzeuge, wobei Werkzeuge, die mit 'B' anfangen, bevorzugt werden
			table.sort(bptools, function(a, b)
				a, b = tostring(a), tostring(b)
				if (a:sub(1, 1) == "B" and b:sub(1, 1) == "B") then
					return a < b  -- Wenn beide mit 'B' anfangen, sortiere sie alphabetisch
				end
				return a > b  -- Ansonsten in umgekehrter Reihenfolge
			end)
	
			local fatass = false  -- Flagge, um zu prüfen, ob das Tool bereits abgelegt wurde
			-- Gehe durch jedes Werkzeug, um es an das richtige Haus zu liefern
			for i = 1, #bptools do
				if not doDelivery then
					break  -- Wenn der Liefermodus deaktiviert ist, beende die Schleife
				end
	
				local tool = bptools[i]  -- Das aktuelle Werkzeug, das geliefert werden soll
				local giver = getHousePart(tool.Name)  -- Hole das Hausteil, das das Werkzeug erhalten soll
				local ogp = giver.Position  -- Speichere die ursprüngliche Position des Hauses
	
				if giver then
					-- Wenn der Spieler zu weit vom Haus entfernt ist, teleportiere ihn näher
					if (giver.Position - root.Position).Magnitude > 9 then
						smoothTP(giver.CFrame + Vector3.new(0, 4, 0))  -- Teleportiere den Spieler zum Haus
						if giver.Parent == nil or (giver.Position - ogp).Magnitude > 1 then
							-- Wenn das Haus nicht mehr existiert oder sich weit bewegt hat, hole das Hausteil erneut
							giver = getHousePart(tool.Name) or giver
							smoothTP(giver.CFrame + Vector3.new(0, 4, 0))  -- Teleportiere wieder hin
						end
						pcall(function() tool.Parent = character end)  -- Versuche, das Werkzeug auszustatten
						wait(1.6)  -- Warte, um sicherzustellen, dass der Prozess abgeschlossen ist
	
						-- Überprüfe alle Werkzeuge im Character und verschiebe sie wieder in den Rucksack, falls nötig
						local t = FindAllDeliveryTools(character)
						for i = 1, #t do
							if t[i] ~= tool then
								t[i].Parent = player.Backpack
							end
						end
						wait(3)  -- Warte 3 Sekunden, um sicherzustellen, dass die Lieferung abgeschlossen ist
						fatass = false  -- Setze fatass auf false, falls das Werkzeug erfolgreich abgelegt wurde
					else
						-- Wenn das Werkzeug bereits abgelegt wurde, warte eine kurze Zeit
						if fatass then
							wait(1)
						else
							wait(1.2)
						end
						pcall(function() tool.Parent = character end)  -- Stelle sicher, dass das Werkzeug korrekt ausgerüstet wird
						wait()  -- Warte, um sicherzustellen, dass der Vorgang abgeschlossen ist
						fatass = true  -- Setze fatass auf true, um zu verhindern, dass das Werkzeug wieder abgelegt wird
					end
				end
			end
			delTick = tick(0.1)  -- Setze die Zeit des letzten Liefervorgangs
		end
	end
	
	wait(2)
	tryCook()
	if doSupplier then  -- Wenn der Supplier-Modus aktiviert ist, gehe weiter
		local refill = false  -- Variable, die angibt, ob eine Auffüllung notwendig ist
	
		-- Überprüfe, ob einer der Vorratsschubladen weniger als den Schwellenwert erreicht hat
		for s, c in pairs(supplyCounts) do
			if c <= settings.refill_at then
				refill = true  -- Wenn ein Vorrat unter den festgelegten Schwellenwert fällt, setze refill auf true
				break  -- Breche die Schleife ab, weil keine weiteren Prüfungen nötig sind
			end
		end
	
		-- Wenn eine Auffüllung erforderlich ist, beginne mit dem Auffüllprozess
		if refill then
			local oldcf = root.CFrame  -- Speichere die aktuelle Position des Spielers
			local waiting = false  -- Flagge, die anzeigt, ob auf Boxen gewartet wird
			local waitingTick = 0.5  -- Speichert den Zeitpunkt, ab dem gewartet wird
			local lastBox  -- Speichert die letzte Box, die bewegt wurde
	
			-- Beginne den Auffüllprozess und gehe weiter, solange der Supplier-Modus aktiv ist
			while doSupplier do
				local fulfilled = true  -- Flagge, die angibt, ob alle Auffüllungen erledigt sind
				local boxes = workspace.AllSupplyBoxes:GetChildren()  -- Alle Boxen im Workspace werden abgerufen
	
				-- Schleife von 1 bis 7, um den Auffüllvorgang mehrfach zu versuchen
				for yy = 1,12 do
					local needtp = true  -- Flagge, die angibt, ob der Spieler teleportiert werden muss
					local realc = 0  -- Zähler für die Boxen, die bewegt wurden
	
					-- Gehe durch alle Versorgungsbuttons, um zu prüfen, ob eine Auffüllung notwendig ist
					for _, btn in ipairs(supplyButtons) do
						local s = bcolorToSupply[btn.BrickColor.Name]  -- Bestimme, welchen Vorrat dieser Button benötigt
	
						-- Wenn der Vorrat unter dem Endwert liegt, muss er aufgefüllt werden
						if supplyCounts[s] < settings.refill_end then
							local count = 0  -- Zähler für Boxen, die noch bewegt werden müssen
	
							-- Wenn mehr als 30 Boxen existieren, überprüfe die Position jeder Box
							if #boxes > 25 then
								for i = 1, #boxes do
									local box = boxes[i]
									if bcolorToSupply[box.BrickColor.Name] == s and box.Anchored == false and box.Position.Z < -940 then
										count = count + 1  -- Zähle, wie viele Boxen noch in der richtigen Position sind
									end
								end
							end
	
							-- Wenn weniger als 2 Boxen in der richtigen Position sind, teleportiere den Spieler zum Button
							if count < 2 then
								if needtp then
									needtp = false
									smoothTP(btn.CFrame + Vector3.new(0, 3, 2.5))  -- Teleportiere den Spieler leicht über den Button
									wait(0.5)  -- Warte kurz, um sicherzustellen, dass der Spieler teleportiert wurde
								end
								if not doSupplier then break end  -- Wenn der Supplier-Modus deaktiviert wird, beende die Schleife
	
								-- Bewege den Spieler an die Position des Buttons und warte
								root.CFrame = btn.CFrame + Vector3.new(0, 3, 0)
								wait(0.5)
								realc = realc + 1  -- Erhöhe den Zähler für bewegte Boxen
							end
							fulfilled = false  -- Setze fulfilled auf false, da noch nicht alle Boxen aufgefüllt wurden
						end
					end
					wait(0.3)  -- Kurze Pause, bevor die nächste Überprüfung stattfindet
	
					-- Wenn weniger als 3 Boxen bewegt wurden, warte noch eine halbe Sekunde
					if yy == 1.2 and realc < 3 then
						wait(0.4)
					end
				end
	
				-- Wenn alle Boxen aufgefüllt sind oder der Supplier-Modus deaktiviert wurde, beende die Schleife
				if fulfilled or not (doSupplier) then
					break
				end
	
				-- Wenn der Auffüllvorgang noch nicht abgeschlossen ist, teleportiere den Spieler zu einer neuen Position
				smoothTP(CFrame.new(8, 12.4, -1020))
	
				-- Wenn der Supplier-Modus deaktiviert wurde, beende die Schleife
				if not doSupplier then break end
	
				-- Wenn der Spieler auf Boxen wartet, überprüfe, ob die Boxen sich bewegen
				if waiting and (lastBox.Position.X > 42 or tick() - waitingTick > 6) then
					waiting = false  -- Setze waiting auf false, wenn das Warten zu lange dauert
					if lastBox.Position.X < 42 then
						wait(0.3)
						-- Wenn die Boxen sich nicht korrekt bewegen, bewege sie manuell
						smoothTP(CFrame.new(20.5, 8, -35))
						wait(0.3)
						local boxes = workspace.AllSupplyBoxes:GetChildren()
						for i = 1, #boxes do
							local box = boxes[i]
							if box.Anchored == false and box.Position.Z > -55 then
								-- Bewege die Boxen, wenn sie in der Nähe des Ziels sind
								network:FireServer("UpdateProperty", box, "CFrame", CFrame.new(RNG:NextNumber(0, 40), RNG:NextNumber(-10, -30), -70))
								wait(0.2)  -- Kurze Pause zwischen den Bewegungen der Boxen
							end
						end
						wait(0.2)  -- Kurze Pause nach dem Bewegen der Boxen
					end
				end
	
				-- Wenn nicht auf Boxen gewartet wird, bewege die Boxen weiter
				if not waiting then
					-- Wenn der Spieler zu nah am Z-Startpunkt ist, teleportiere ihn weiter weg
					if root.Position.Z > -900 then smoothTP(CFrame.new(8, 12.4, -1020)) end
					wait(0.4)
					lastBox = nil  -- Setze die letzte Box auf nil
					local j = 0  -- Zähler für die Boxen
	
					-- Gehe durch alle Boxen, um die Position jeder Box zu überprüfen und ggf. zu bewegen
					local boxes = workspace.AllSupplyBoxes:GetChildren()
					for i = 1, #boxes do
						local box = boxes[i]
						if box.Anchored == false and box.Position.Z < -940 and bcolorToSupply[box.BrickColor.Name] and supplyCounts[bcolorToSupply[box.BrickColor.Name]] < settings.refill_end then
							-- Bewege die Boxen in die passende Position
							box.CFrame = CFrame.new(38 - 4.3 * math.floor(j / 2), 5, -7 - 5 * (j % 2))
							network:FireServer("UpdateProperty", box, "CFrame", box.CFrame)
							lastBox = box  -- Speichere die letzte bewegte Box
							j = j + 1
							if j > 13 then break end  -- Wenn mehr als 13 Boxen bewegt wurden, beende die Schleife
						end
					end
	
					-- Wenn eine Box bewegt wurde, beginne zu warten
					if lastBox then
						waiting = true
						waitingTick = tick(1)  -- Setze den Zeitpunkt des Wartens
					end
				end
			end
		end
	end
	

	if not (doCashier or doCook or doBoxer or doDelivery or doSupplier) then
		print("Alle Funktionen deaktiviert. Schleife wird gestoppt.")
		loopEnabled = false
		loopThread = nil -- Beende den Thread
		return
	end
end
end)
end
local sectionSettings = window:CreateTab("Settings", 4483362458)

sectionSettings:CreateToggle({
    Name = "Alle Aktivieren",
    CurrentValue = false, -- Standardmäßig deaktiviert
    Flag = "allEnabled",
    Callback = function(bool)
        -- Setze alle anderen Toggles auf den gleichen Wert wie "Alle Aktivieren"
        doCashier = bool
        doCook = bool
        doBoxer = bool
        doDelivery = bool
        doSupplier = bool

        -- Debugging-Ausgabe
        print("Alle Toggles geändert:", bool)

        -- Aktualisiere die GUI-Toggles visuell
        Rayfield.Flags["doCashier"]:Set(bool)
        Rayfield.Flags["doCook"]:Set(bool)
        Rayfield.Flags["doBoxer"]:Set(bool)
        Rayfield.Flags["doDelivery"]:Set(bool)
        Rayfield.Flags["doSupplier"]:Set(bool)

        -- Aktualisiere die Schleife
        loopEnabled = doCashier or doCook or doBoxer or doDelivery or doSupplier
        if loopEnabled then
            startLoop()
        end
    end
})

-- Einzelne Toggles
sectionSettings:CreateToggle({
    Name = "Cashier Aktivieren",
    CurrentValue = doCashier,
    Flag = "doCashier",
    Callback = function(bool)
        doCashier = bool
        print("Cashier-Toggle geändert:", bool)
        loopEnabled = doCashier or doCook or doBoxer or doDelivery or doSupplier
        if loopEnabled then startLoop() end
    end
})

sectionSettings:CreateToggle({
    Name = "Cook Aktivieren",
    CurrentValue = doCook,
    Flag = "doCook",
    Callback = function(bool)
        doCook = bool
        print("Cook-Toggle geändert:", bool)
        loopEnabled = doCashier or doCook or doBoxer or doDelivery or doSupplier
        if loopEnabled then startLoop() end
    end
})

sectionSettings:CreateToggle({
    Name = "Boxer Aktivieren",
    CurrentValue = doBoxer,
    Flag = "doBoxer",
    Callback = function(bool)
        doBoxer = bool
        print("Boxer-Toggle geändert:", bool)
        loopEnabled = doCashier or doCook or doBoxer or doDelivery or doSupplier
        if loopEnabled then startLoop() end
    end
})

sectionSettings:CreateToggle({
    Name = "Delivery Aktivieren",
    CurrentValue = doDelivery,
    Flag = "doDelivery",
    Callback = function(bool)
        doDelivery = bool
        print("Delivery-Toggle geändert:", bool)
        loopEnabled = doCashier or doCook or doBoxer or doDelivery or doSupplier
        if loopEnabled then startLoop() end
    end
})

sectionSettings:CreateToggle({
    Name = "Supplier Aktivieren",
    CurrentValue = doSupplier,
    Flag = "doSupplier",
    Callback = function(bool)
        doSupplier = bool
        print("Supplier-Toggle geändert:", bool)
        loopEnabled = doCashier or doCook or doBoxer or doDelivery or doSupplier
        if loopEnabled then startLoop() end
    end
})

-- Refill Einstellungen
sectionSettings:CreateSlider({
    Name = "Refill At",
    Range = { 0, 99 },
    Increment = 1,
    Suffix = "%",
    CurrentValue = settings.refill_at,
    Flag = "refill_at",
    Callback = function(value)
        settings.refill_at = value
    end
})

sectionSettings:CreateSlider({
    Name = "Refill End",
    Range = { 0, 99 },
    Increment = 1,
    Suffix = "%",
    CurrentValue = settings.refill_end,
    Flag = "refill_end",
    Callback = function(value)
        settings.refill_end = value
    end
})

sectionSettings:CreateSlider({
    Name = "Movespeed",
    Range = { 0, 50 },
    Increment = 1,
    Suffix = "Speed",
    CurrentValue = settings.movespeed_at,
    Flag = "movespeed_at",
    Callback = function(value)
        settings.movespeed_at = value -- This should be within the Callback function
    end
})


-- Warte-Schleife, damit das GUI nicht sofort geschlossen wird
wait(5) -- Wartezeit kann angepasst werden
-- Info-Anzeige beim Schließen
Rayfield:Notify({
Title = "Beendet",
Content = "Das GUI wurde geschlossen.",
Duration = 3
})

